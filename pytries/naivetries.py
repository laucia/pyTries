import logging
import collections
import pickle


################################# README ######################################
#
# Python dictionnary are used as a base for the nodes for fast child retrieval
# through arbitrary char-based key.
#
# The current implementation is very efficient in retriaval, but the memory
# usage is not really optimized.
#
################################# README ######################################




# setting logging
logging.getLogger().setLevel(logging.INFO)

# name for the dumping of the complete tree
DUMP_NAME = "trie.dump"


class TrieNode(collections.MutableMapping):
    '''
    Class representing a node in the trie.
    
    It's a dictionnary with extra attribute, and transformation 
    to be sure only to manipulate lowercase 

    The children are stocked in a dictionnary like structure, 
    the key being the letter

    '''

    def __init__(self, *args, **kwargs):
        self.is_word = False
        self.store = dict()
        self.update(dict(*args, **kwargs)) 

    def __getitem__(self, key):
        return self.store[self.__keytransform__(key)]

    def __setitem__(self, key, value):
        self.store[self.__keytransform__(key)] = value

    def __delitem__(self, key):
        del self.store[self.__keytransform__(key)]

    def __iter__(self):
        return iter(self.store)

    def __len__(self):
        return len(self.store)

    def __str__(self):
        return self.store.__str__()

    def __keytransform__(self, key):
        return key.lower()

    def _unpack_trie(self, prefix):
        '''
        Recursive function to get the list of the words encoded
        in the sub-tree generated by this node.

        '''
        pack = []
        if self.is_word:
            pack.append(prefix)
        for key, child_node in self.items():
            pack+=(child_node._unpack_trie(prefix+key))
        return pack


class Trie(TrieNode):
    '''
    Represents the root of the Trie structure.
    Allows creation/filling of the structure

    '''

    def add_word(self, word):
        '''
        Add a word in the Trie structure

        '''
        if len(word) == 0:
            logging.warning("Empty Word - Nothing to do")
            return -1
        trie = self
        for char in word:
            try:
                trie = trie[char]
            except KeyError:
                new_trie = TrieNode()
                trie[char]= new_trie
                trie = new_trie
        trie.is_word = True
        logging.debug("%s added" % word)

    def dump(self):
        '''
        Create a file to hold the already processed datas

        Only works on small Trie unfortunatly.
        The Trie should be subdivded or saved in a database
        for continued use

        '''
        dump_file = open(DUMP_NAME,'w+')
        pickle.dump(self,dump_file)
        dump_file.close()

    @staticmethod
    def load():
        '''
        Load a file that hold the already processed datas

        Only works on small Trie unfortunatly.
        The Trie should be subdivded or saved in a database
        for continued use

        '''
        try:
            dump_file = open(DUMP_NAME,'r')
            trie = pickle.load(dump_file)
            dump_file.close()
            return trie
        except IOError:
            logging.warn('No dump file found')
            return None

    def fill(self, data_file):
        '''
        Initialize the Trie with the content of a file.
        The file should have a word per line

        '''
        data = open(data_file,'r')
        for line in data:
            self.add_word(line.strip())
        data.close()

    def get_autocomplete(self,word):
        '''
        Get the words stocked in the trie that could complete the 
        given input

        '''
        node = self
        try:
            for char in word:
                node = node[char]
        except KeyError:
            return []

        return node._unpack_trie(word)




